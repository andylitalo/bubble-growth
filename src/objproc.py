"""objproc.py contains functions used for processing objects
generated by the object-tracking algorithm in
bubbletracking_koe/src/main.py

Author: Andy Ylitalo
Date: February 26, 2022
"""

# 3rd party libraries
import numpy as np

# custom libraries
import sys
sys.path.append('../libs/')
import fn
from conversions import *



def calc_L(obj):
    """
    Calculates the length of the object at all observation points [um].

    Parameters
    ----------
    obj : dictionary
        TrackedObj converted to dictionary from bubbletracking_koe

    Returns
    -------
    L_list : list of floats
        Length of object in each frame with an observation [um].
    """
    # gets bounding box
    bbox_list = obj['props_raw']['bbox']
    # gets unit conversion
    pix_per_um = obj['metadata']['pix_per_um']
    # computes length
    L_list = [(c_hi - c_lo)/pix_per_um for _, c_lo, _, c_hi in bbox_list]

    return L_list


def calc_t(obj, d, v_max):
    """
    Computes time since entering observation capillary [s].

    Parameters
    ----------
    obj : dictionary
        TrackedObj converted to dictionary from bubbletracking_koe
    d : float
        Distance along observation capillary at which video was taken [m].
    v_max : float
        Estimated speed of flow at center (maximum) [m/s].

    Returns
    -------
    t : numpy array of floats
        Estimated time since flow entered observation capillary of each
        observation of the object [s].
    """
    # gets timeline of bubble (starts at zero) [s]
    frame_list = obj['props_raw']['frame']
    fps = obj['metadata']['fps']
    t_fov = (np.asarray(frame_list) - frame_list[0]) / fps
    # computes time of first observation relative to center of field of view
    num_col_frame = obj['metadata']['frame_dim'][1] # number of columns in frame
    pix_per_um = obj['metadata']['pix_per_um'] # conversion factor
    col_first_obs = obj['props_raw']['bbox'][0][1] # row_lo, *col_lo*, row_hi, col_hi
    # distance along capy of first observation [m]
    d_first_obs = d + ((col_first_obs - num_col_frame/2) / pix_per_um) * um_2_m
    t_first_obs = d_first_obs / v_max
    # adds field-of-view time to time of first observation [s]
    t = t_fov + t_first_obs

    return t


def calc_W(obj):
    # computes width [um]
    bbox_list = obj['props_raw']['bbox']
    pix_per_um = obj['metadata']['pix_per_um']
    W_list = [(r_hi - r_lo)/pix_per_um for r_lo, _, r_hi, _ in bbox_list]

    return W_list


def get_conditions(metadata):
    """Gets conditions of experiment."""
    # saturation pressure and units
    _, p_sat, units = fn.parse_vid_dir(metadata['vid_subdir'])
    # distance along channel [m]
    d = metadata['object_kwargs']['d']
    # polyol
    polyol = fn.parse_vid_path(metadata['vid_name'])['prefix'].split('_')[0]
    # estimated pressure in given units
    L = metadata['L'] # length of observation capillary [m]
    p_in = -metadata['object_kwargs']['dp']
    p_est = (1 - d/L)*p_in # [Pa]
    if units == 'bar':
        p_sat *= bar_2_Pa
    elif units == 'mpa':
        p_sat *= MPa_2_Pa
    elif units == 'psi':
        p_sat *= psi_2_Pa
    else:
        print('Units "{0:s}" not recognized.'.format(units))

    L = metadata['L'] # length of observation capillary [m]
    p_in = -metadata['object_kwargs']['dp'] # inlet pressure est w flow eqns [Pa]
    v_max = metadata['object_kwargs']['v_max'] # centerline speed [m/s] est w flow eqns

    # computes time to reach center of field of view
    t_center = d / v_max

    return p_in, p_sat, p_est, p_in, d, L, v_max, t_center, polyol


def get_valid_idx(obj, L_frac=1):
    """
    Gets indices of frames where object has valid
    properties for fitting early growth, meaning
    the object is not on the border and is not too
    oblong.
    """
    # gets bubble size [um]
    # W_bub = np.asarray(calc_W(obj))
    L_bub = np.asarray(calc_L(obj))
    # gets valid indices (eliminates where on border or where bubble is too long
    not_on_border = np.logical_not(np.asarray(obj['props_raw']['on border']))
    R_i = obj['metadata']['R_i']*m_2_um # [um]
    not_too_long = L_bub < 2*R_i * L_frac
    idx = np.logical_and(not_on_border, not_too_long)

    return idx


def is_true_obj(obj, true_props=['inner stream', 'oriented', 'consecutive', 'exited', 'centered']):
    """Returns True if true object and False if not."""
    for prop in true_props:
        # if lacks one of the key props for a true object, not a true object
        try:
            props = obj['props_proc'][prop]
            if False in props:
                return False
        except:
            print('DATA ARE MISSING TRUE PROPERTIES. Please rerun analysis.')
            continue

    return True
