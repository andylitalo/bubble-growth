"""objproc.py contains functions used for processing objects
generated by the object-tracking algorithm in
bubbletracking_koe/src/main.py

Author: Andy Ylitalo
Date: February 26, 2022
"""

# 3rd party libraries
import numpy as np

# custom libraries
import sys
sys.path.append('../libs/')
import fn
from conversions import *



def calc_L(obj):
    """
    Calculates the length of the object at all observation points [um].
    
    Parameters
    ----------
    obj : dictionary
        TrackedObj converted to dictionary from bubbletracking_koe
    
    Returns
    -------
    L_list : list of floats
        Length of object in each frame with an observation [um].
    """
    # gets bounding box
    bbox_list = obj['props_raw']['bbox']
    # gets unit conversion
    pix_per_um = obj['metadata']['pix_per_um']
    # computes length
    L_list = [(c_hi - c_lo)/pix_per_um for _, c_lo, _, c_hi in bbox_list]
    
    return L_list


def calc_t(obj, d, v_max):
    """
    Computes time since entering observation capillary [s].
    
    Parameters
    ----------
    obj : dictionary
        TrackedObj converted to dictionary from bubbletracking_koe
    d : float
        Distance along observation capillary at which video was taken [m].
    v_max : float
        Estimated speed of flow at center (maximum) [m/s].
        
    Returns
    -------
    t : numpy array of floats
        Estimated time since flow entered observation capillary of each
        observation of the object [s].        
    """
    # gets timeline of bubble (starts at zero) [s]
    frame_list = obj['props_raw']['frame']
    fps = obj['metadata']['fps']
    t_fov = (np.asarray(frame_list) - frame_list[0]) / fps 
    # computes time of first observation relative to center of field of view
    num_col_frame = obj['metadata']['frame_dim'][1] # number of columns in frame
    pix_per_um = obj['metadata']['pix_per_um'] # conversion factor
    col_first_obs = obj['props_raw']['bbox'][0][1] # row_lo, *col_lo*, row_hi, col_hi
    # distance along capy of first observation [m]
    d_first_obs = d + ((col_first_obs - num_col_frame/2) / pix_per_um) * um_2_m 
    t_first_obs = d_first_obs / v_max
    # adds field-of-view time to time of first observation [s]
    t = t_fov + t_first_obs
        
    return t

        
def calc_W(obj):
    # computes width [um]
    bbox_list = obj['props_raw']['bbox']
    pix_per_um = obj['metadata']['pix_per_um']
    W_list = [(r_hi - r_lo)/pix_per_um for r_lo, _, r_hi, _ in bbox_list]
    
    return W_list


def get_conditions(metadata):
    """Gets conditions of experiment."""
    # saturation pressure and units
    _, p_sat, units = fn.parse_vid_dir(metadata['vid_subdir'])
    # distance along channel [m]
    d = metadata['object_kwargs']['d']
    # polyol
    polyol = fn.parse_vid_path(metadata['vid_name'])['prefix'].split('_')[0]
    # estimated pressure in given units
    L = metadata['L'] # length of observation capillary [m]
    p_in = -metadata['object_kwargs']['dp']
    p_est = (1 - d/L)*p_in # [Pa]
    if units == 'bar':
        p_sat *= bar_2_Pa
    elif units == 'mpa':
        p_sat *= MPa_2_Pa
    elif units == 'psi':
        p_sat *= psi_2_Pa
    else:
        print('Units "{0:s}" not recognized.'.format(units))
        
    return p_sat, p_est, d, polyol


def is_true_obj(obj, true_props=['inner stream', 'oriented', 'consecutive', 'exited', 'centered']):
    """Returns True if true object and False if not."""
    for prop in true_props:
        # if lacks one of the key props for a true object, not a true object
        try:
            props = obj['props_proc'][prop]
            if False in props:
                return False
        except:
            print('DATA ARE MISSING TRUE PROPERTIES. Please rerun analysis.')
            continue
        
    return True 